# Cравнение C++ и Python

---

### 1. **Структурное программирование**
- **C++**:  
  - Блоки — фигурные скобки `{}`.  
  - Условия: `if`/`else`, `switch`.  
  - Циклы: `for`, `while`, `do-while`.  
  - Обязательны точки с запятой `;` как терминаторы.

    ```cpp
    if (x > 0) {
        while (i < 10) {
            i++;
        }
    }
    ```
    ---
- **Python**:  
  - Блоки — отступы (whitespace-sensitive).  
  - Условия: `if`/`elif`/`else`.  
  - Циклы: `for` (итеративный), `while`.  
  - Нет `;`, конец строки = конец оператора (кроме `\` и многострочных конструкций).

    ```python
    if x > 0:
        while i < 10:
            i += 1
    ```

---
> **Итог**: Python требует отслеживания уровня отступа в лексере; C++ проще — только скобки и `;`.
---

### 2. **Операторы**
- **C++**:  
  - Богатый набор: `++`, `--`, `+=`, `?:`, побитовые (`&`, `|`, `^`, `~`, `<<`, `>>`), логические (`&&`, `||`), сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`).  
  - Приоритеты сложные, но фиксированные.

    ```cpp
    a = b + c;
    x = (y > 0) ? 1 : 0;
    z <<= 2;
    ```
    ---

- **Python**:  
  - Нет инкрементов/декрементов.  
  - Логические: `and`, `or`, `not`.  
  - Побитовые: `&`, `|`, `^`, `~`, `<<`, `>>`.  
  - Сравнения: те же, плюс цепочки (`a < b < c`).  
  - Уникальные: `is`, `in`, `//`, `**`.

    ```python
    a = b + c
    x = 1 if y > 0 else 0
    z <<= 2
    ```
---
> **Итог**: Python проще в лексике (меньше символьных операторов), но требует обработки ключевых слов как операторов и цепочек сравнений.
---

### 3. **Базовые типы данных**
- **C++**:  
  - Статическая типизация.  
  - Примитивы: `int`, `float`, `double`, `char`, `bool`, указатели.  
  - Размеры фиксированы (платформозависимо).

    ```cpp
    int n = 42;
    double pi = 3.14;
    bool flag = true;
    ```
    ---

- **Python**:  
  - Динамическая типизация.  
  - Примитивы: `int`, `float`, `bool`, `str`, `None`.  
  - `int` — произвольной точности.

    ```python
    n = 42
    pi = 3.14
    flag = True
    ```
---
> **Итог**: В C++ типы декларируются явно → проще построить таблицу символов на этапе парсинга. В Python типы определяются позже → AST не содержит типов.
---

### 4. **Пользовательские функции**
- **C++**:  
  - Объявление с типами аргументов и возвращаемого значения.  
  - Поддержка перегрузки.  
  - Рекурсия — разрешена.  
  - Параметры: по значению, по ссылке, по указателю.

    ```cpp
    int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    ```
    ---

- **Python**:  
  - `def name(params):` — без типов (в учебном подмножестве).  
  - Нет перегрузки.  
  - Рекурсия — разрешена.  
  - Параметры: всегда по ссылке на объект (передача "по значению ссылки").

    ```python
    def factorial(n):
        if n <= 1:
            return 1
        return n * factorial(n - 1)
    ```

---
> **Итог**: C++ требует обработки сигнатур с типами; Python — только имена параметров.
---

### 5. **Пользовательские структуры**
- **C++**:  
  - `struct` / `class` с полями и методами.  
  - Поля имеют типы.  
  - Доступ через `.` или `->`.

    ```cpp
    struct Point {
        int x;
        int y;
    };
    ```
    ---

- **Python**:  
  - Классы через `class`; учебный подмножество может использовать только поля.  
  - Нет объявлений полей — создаются динамически.  
  - Доступ через `.`.
    ```python
    class Point:
        pass
    # или (динамически)
    p = Point()
    p.x = 10
    ```
---
> **Итог**: C++ — парсинг полей с типами. Python — достаточно имени класса; поля не объявляются.
---

### 6. **Работа со строками**
- **C++**:  
  - Две модели: `char[]` (C-style) и `std::string`.  
  - Литералы в кавычках `"..."`.  
  - Escape-последовательности: `\n`, `\t`, `\\`, `\"`.

    ```cpp
    char s1[] = "hello";
    std::string s2 = "world\n";
    ```
    ---

- **Python**:  
  - Единый тип `str`.  
  - Литералы: `'...'`, `"..."`, `'''...'''`, `"""..."""`.  
  - Escape-последовательности + raw-строки (`r"..."`).

    ```python
    s1 = 'hello'
    s2 = "world\n"
    s3 = """multi
    line"""
    s4 = r"C:\path"
    ```
---
> **Итог**: Python сложнее — нужно поддерживать 4 вида кавычек и raw-строки. C++ проще, но требует обработки escape и различения строк от символов (`'c'`).
---

### 7. **Работа с массивами**
- **C++**:  
  - Статические массивы: `int a[10];`  
  - Динамические: через указатели или `std::vector`.  
  - Индексация: `a[i]`.

    ```cpp
    int arr[3] = {1, 2, 3};
    int x = arr[i];
    ```
    ---

- **Python**:  
  - Единый тип `list` (динамический массив).  
  - Литералы: `[1, 2, 3]`.  
  - Индексация: `a[i]`, срезы `a[i:j]`.

    ```python
    arr = [1, 2, 3]
    x = arr[i]
    y = arr[1:3]
    ```
---
> **Итог**: Python требует поддержки синтаксиса списков и срезов. C++ — только индексации и, возможно, инициализаторов `{...}`.
---

### 8. **Управление памятью**
- **C++**:  
  - Явное: `new`/`delete`, стек vs куча.  
  - Указатели и ссылки.
    ```cpp
    int* p = new int(42);
    delete p;
    int a = *p;
    ```
    ---

- **Python**:  
  - Автоматическое (сборка мусора).  

    ```python
    # Нет явного управления
    x = [1, 2, 3]  # автоматически удаляется при выходе из области
    ```
---
> **Итог**: C++ — токены `*`, `&`, `new`, `delete`. Python — ничего.
---

### 9. **Обработка ошибок**
- **C++**:  
  - Исключения: `try`/`catch`/`throw`.  
  - Также: коды возврата, assert.

    ```cpp
    try {
        throw 42;
    } catch (int e) {
        // handle
    }
    ```
    ---

- **Python**:  
  - Исключения: `try`/`except`/`finally`/`raise`.  
  - Распространённый стиль — "Easier to Ask for Forgiveness than Permission" (EAFP).

    ```python
    try:
        raise ValueError("oops")
    except ValueError as e:
        pass
    ```
---
> **Итог**: Оба требуют поддержки блоков исключений, но синтаксис разный. Python проще — нет типов исключений в `except` (в базовом случае).
---

Итоговое сравнение C++ и Python с точки зрения реализации **фронтенда** (лексический и синтаксический анализ, построение AST) учебного компилятора:

| Критерий | C++ | Python | Сложность для фронтенда |
|--------|------|--------|--------------------------|
| **1. Структурное программирование** | Блоки через `{}`, обязательные `;` | Блоки через отступы, нет `;` | **C++ проще**: чёткие делимитеры. **Python сложнее**: нужен стек отступов (`INDENT`/`DEDENT`). |
| **2. Операторы** | Много символьных (`++`, `?:`, `<<=`, `&&`) | Ключевые слова (`and`, `or`), цепочки сравнений, `**`, `//` | **C++ сложнее**: плотная символика, приоритеты. **Python проще**, но требует обработки ключевых слов как операторов. |
| **3. Базовые типы** | Явные (`int`, `double`, `bool`) | Не объявляются, динамические | **C++ сложнее**: типы входят в AST. **Python проще**: типы не нужны на этапе парсинга. |
| **4. Функции** | Сигнатура с типами, перегрузка | Только имя и параметры | **C++ сложнее**: парсинг типов в сигнатуре. **Python проще**: минималистичное объявление. |
| **5. Структуры** | `struct` с типизированными полями | `class` без объявлений полей | **C++ сложнее**: парсинг полей с типами. **Python проще**: достаточно имени. |
| **6. Строки** | `"..."`, escape-последовательности | `'...'`, `"..."`, `'''...'''`, `"""..."""`, raw-строки | **Python сложнее**: 4 вида кавычек + raw-строки. **C++ проще**, но нужно различать `'c'` и `"s"`. |
| **7. Массивы** | Статические `T[N]`, инициализаторы `{}` | Динамические списки `[...]`, срезы `[i:j]` | **Python сложнее**: синтаксис срезов → новый AST-узел. **C++ проще**, но есть инициализаторы. |
| **8. Управление памятью** | `new`/`delete`, указатели `*`, ссылки `&` | Нет явного управления | **C++ сложнее**: дополнительные токены и операторы. **Python проще**: ничего не парсить. |
| **9. Обработка ошибок** | `try`/`catch (Type)`/`throw` | `try`/`except [as]`/`raise` | Примерно одинаково: оба требуют блоков исключений. C++ чуть сложнее из-за типов в `catch`. |

### Общий вывод
- **C++** требует **более сложного лексера и парсера** из-за богатой символики, явной типизации и низкоуровневых конструкций. Зато структура кода однозначна (скобки, точки с запятой).
- **Python** проще в грамматике выражений и отсутствии типов, но **лексер значительно сложнее**: whitespace-чувствительность, многострочные строки, raw-строки, отсутствие явных делимитеров блоков.
