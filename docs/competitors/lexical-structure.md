# **Сравнение лексической структуры C++ и Python (императивная часть)**

## 1. **Элементы структурного программирования**
### 1.1. **Блоки кода**

- **Python**:  
  - Блоки определяются **уровнем отступа** (leading whitespace).  
  - Лексический анализатор генерирует токены `INDENT` и `DEDENT` на основе сравнения уровней отступов.  
  - Отступы могут быть пробелами или табами, но их смешение запрещено (`TabError`).  
  - Блок начинается после двоеточия (`:`) в заголовке составного оператора:  
    ```python
    if x > 0:
        print("positive")
    ```

- **C++**:  
  - Блоки ограничиваются **фигурными скобками `{}`**.  
  - Отступы не влияют на лексику — это чисто стилистический элемент.  
  - Пример:
    ```cpp
    if (x > 0) 
    {
        std::cout << "positive";
    }
    ```

---

### 1.2. **Ветвления**

- **Python**:  
  - Ключевые слова: `if`, `elif`, `else`.  
  - Условие следует сразу после `if` без скобок.  
  - Требуется `:` в конце заголовка.  
  - Лексически: `if` → `expr` → `:` → `INDENT` → тело → `DEDENT`.
    ```python
    if score >= 90:
      grade = 'A'
    elif score >= 80:
      grade = 'B'
    else:
      grade = 'C'
    ```

- **C++**:  
  - Ключевые слова: `if`, `else`.  
  - Условие  — **в круглых скобках**.  
  - Блок — в `{}` или одна инструкция.
    ```cpp
    if (score >= 90) 
    {
      grade = 'A';
    } 
    else if (score >= 80) 
    {
      grade = 'B';
    }
    else 
    {
      grade = 'C';
    }
    ```

---

### 1.3. **Циклы**

- **Python**:  
  - `for` и `while`.  
  - Синтаксис:  
    ```python
    for i in range(10):
        print(i)

    while x > 0:
        print(i)
    ```
  - Нет `do-while`.  
  - Заголовок завершается `:`, тело — отступом.

- **C++**:  
  - Поддерживает `for`, `while`, `do-while`.  
  - Все условия в скобках, тело — в `{}` или одна инструкция.
    ```cpp
    // for-цикл
    for (int i = 0; i < 3; ++i) 
    {
      std::cout << i << "\n";
    }

    // while-цикл
    int n = 5;
    while (n > 0) 
    {
      std::cout << n << "\n";
      --n;
    }

    // do-while
    int m = 0;
    do 
    {
      std::cout << m << "\n";
      ++m;
    }
    while (m < 3);
    ```

---

## 2. Средства ввода/вывода и встроенные функции

### **Python**
**Bсе имена функций — это идентификаторы**, в том числе встроенные (`print`, `len`, `input`, `int`, `str`, `range`, `abs` и др.).

- Встроенные функции определены в модуле `builtins` и **автоматически доступны** в глобальной области видимости.

В Python ввод и вывод реализуются через **встроенные функции**, такие как `print()` и `input()`. С точки зрения лексического анализа:

- `print` и `input` — это **идентификаторы**.  
  Идентификаторы соответствуют шаблону:  
  ```
  identifier ::= xid_start xid_continue*
  ```
  где `xid_start` — это буква, символ подчёркивания `_` или другие Unicode-символы, разрешённые в начале имени.  
  Таким образом, `print` — это корректный идентификатор, определённый в модуле `builtins`.

- Круглые скобки `(` и `)` — это **delimiters** (разделители), как указано в [разделе 2.2](https://docs.python.org/3/reference/lexical_analysis.html#other-tokens). Они не являются операторами, а служат для группировки и вызова функций.

- Аргументы внутри скобок разделяются **запятыми `,`**, которые также являются **delimiters**, а не операторами в данном контексте.

  ##### Пример и разбор на токены:
  ```python
  name = input("Enter your name: ")
  print("Hello,", name)
  ```

| Код | Токены |
|-----|--------|
| `input("Enter your name: ")` | `NAME('input')`, `LPAR`, `STRING('"Enter your name: "')`, `RPAR` |
| `print("Hello,", name)` | `NAME('print')`, `LPAR`, `STRING('"Hello,"')`, `COMMA`, `NAME('name')`, `RPAR` |

---

### **C++**
В C++ **нет глобального набора встроенных функций**, доступных без подключения заголовков.
Даже такие базовые операции, как `abs()` или `sqrt()`, требуют `#include <cmath>`.
Функции из стандартной библиотеки находятся в **пространстве имён `std`**.

В C++ ввод и вывод реализуются через **объекты потоков** из стандартной библиотеки:  
- `std::cin` — для ввода,  
- `std::cout` — для вывода.

С точки зрения лексики:

- `std::cout` состоит из:
  - `std` — **идентификатор** (имя пространства имён),
  - `::` — **оператор разрешения области видимости** (scope resolution operator), который является **отдельным токеном-оператором**,
  - `cout` — **идентификатор** (имя объекта в пространстве имён `std`).

- Операторы `<<` (вывод) и `>>` (ввод) — это **бинарные операторы**, перегруженные для работы с потоками. Лексически они представляют собой **одиночные токены** (не два символа `<` подряд, а один оператор `<<`).

- Точка с запятой `;` в конце — обязательный **delimiter**, завершающий инструкцию.

  ##### Пример и разбор на токены:
  ```cpp
  std::cout << "Hello, " << name;
  std::cin >> age;
  ```

| Код | Токены |
|-----|--------|
| `std::cout << "Hello, " << name;` | `IDENTIFIER(std)`, `SCOPE(::)`, `IDENTIFIER(cout)`, `OP(<<)`, `STRING_LITERAL("Hello, ")`, `OP(<<)`, `IDENTIFIER(name)`, `SEMICOLON(;)`|
| `std::cin >> age;` | `IDENTIFIER(std)`, `SCOPE(::)`, `IDENTIFIER(cin)`, `OP(>>)`, `IDENTIFIER(age)`, `SEMICOLON(;)` |
 
- Ввод/вывод — это **не функции**, а **операции с объектами через перегруженные операторы**.  
- Для работы требуется подключить заголовок: `#include <iostream>` (но это обрабатывается препроцессором, до лексического анализа).

---

## 3. **Пользовательские функции**
### **Python**

В Python функция объявляется с помощью оператора `def`. Согласно [разделу 2.3.1](https://docs.python.org/3/reference/lexical_analysis.html#keywords), **`def` — это ключевое слово (hard keyword)**, то есть зарезервированный идентификатор, который нельзя использовать как имя переменной.

Общий синтаксис:
```python
def имя_функции(параметр1, параметр2, ...):
    тело_функции
```


| Элемент | Лексема (токен) | Пояснение |
|--------|------------------|----------|
| `def` | `KEYWORD('def')` | Зарезервированное слово, начинает определение функции |
| `имя_функции` | `NAME('имя_функции')` | Идентификатор, соответствует правилу `xid_start xid_continue*` ([2.3](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)) |
| `(` и `)` | `LPAR`, `RPAR` | **Delimiters** (разделители), как указано в [2.2](https://docs.python.org/3/reference/lexical_analysis.html#other-tokens) |
| `параметр1, параметр2` | `NAME`, `COMMA`, `NAME` | Параметры — это **идентификаторы**, разделённые **запятыми** (`COMMA` — тоже delimiter) |
| `:` | `COLON` | Обязательный delimiter, завершает заголовок функции и открывает блок тела |

#### **Возврат значения**

- Используется оператор `return` — **ключевое слово**.
- Может быть:
  - `return выражение` → возвращает значение,
  - `return` → возвращает `None`.
- **Точка с запятой не обязательна** — конец инструкции определяется по `NEWLINE`.

---

### **C++**

В C++ функция объявляется с указанием **типа возвращаемого значения**, **имени** и **типов всех параметров**. Это требование стандарта языка.

Общий синтаксис:
```cpp
тип_возврата имя_функции(тип1 парам1, тип2 парам2) {
    тело_функции
}
```

| Элемент | Лексема (токен) | Пояснение |
|--------|------------------|----------|
| `int`, `double`, `void` и др. | `TYPE_KEYWORD` или `IDENTIFIER` | Типы — это либо ключевые слова (`int`, `bool`), либо идентификаторы (`MyClass`) |
| `имя_функции` | `IDENTIFIER` | Имя функции — обычный идентификатор (ASCII-only) |
| `(` и `)` | `LPAREN`, `RPAREN` | Разделители списка параметров |
| `тип парам` | `TYPE`, `IDENTIFIER` | Каждый параметр — **пара**: тип + имя |
| `,` | `COMMA` | Разделитель между параметрами |
| `{` и `}` | `LBRACE`, `RBRACE` | Ограничители тела функции |
| `;` | `SEMICOLON` | Обязательно в конце **выражений**, включая `return` |
  
- **Все типы — обязательные лексемы**. Без них код не скомпилируется.  
- **Точка с запятой `;` обязательна** после каждого выражения, включая `return`.

#### **Возврат значения**

- Используется ключевое слово `return`.
- Всегда завершается точкой с запятой: `return выражение;`
- Если функция возвращает `void`, можно писать просто `return;`
---

## 4. Встроенные типы данных

###  4.1. Целые числа (integer literals)

#### **Python**
Целочисленные литералы могут быть записаны в нескольких системах счисления:

- **Десятичная**: `42`  
- **Шестнадцатеричная**: `0x2A` или `0X2A`  
- **Восьмеричная**: `0o52` или `0O52`  
- **Двоичная**: `0b101010` или `0B101010`

**Лексически** — это один токен типа `NUMBER`.  
Ведущие нули **запрещены** в десятичной записи: `042` → `SyntaxError` (в отличие от C++!).  
Целые числа в Python имеют **неограниченную точность** (произвольная длина).

#### **C++**
В C++ поддерживаются:

- **Десятичная**: `42`  
- **Шестнадцатеричная**: `0x2A`  
- **Восьмеричная**: `052` (начинается с нуля, без `o`)  
- **Двоичная**: `0b101010` (C++14+)

**Лексически** — это токены типа `INTEGER_LITERAL`.  
`042` — **восьмеричное число**
Тип литерала зависит от суффиксов (`u`, `l`, `ll`) и контекста.

---

### 4.2. Числа с плавающей точкой (floating point literals)

#### **Python**
В Python числа с плавающей запятой:

- `3.14`  
- `6.02e23` или `6.02E23`  
- `.5` (допустимо — ноль перед точкой можно опустить)  
- `1.` (допустимо — ноль после точки можно опустить)

Все такие литералы — токены `NUMBER`.  
Всегда имеют тип `float` (64-битный, как `double` в C++).

#### **C++**
Поддерживает:

- `3.14` → тип `double`  
- `3.14f` или `3.14F` → тип `float`  
- `3.14l` → тип `long double`  
- `6.02e23` → `double`  
- `.5` и `1.` — допустимы

Тип определяется **суффиксом** (`f`, `l`).  
Без суффикса — `double`.

**Примеры**:
```cpp
3.14    // double
3.14f   // float
.5      // double
1.      // double
```

---

### 4.3. Строки (string literals)

#### **Python**

Формы записи строк:
- Одинарные кавычки: `'hello'`  
- Двойные кавычки: `"hello"`  
- Тройные кавычки: `'''multi\nline'''` или `"""..."""`
- Префиксы:
  - `r"..."` — **raw string** (бэкслеши не обрабатываются)
  - `f"..."` — **formatted string literal** (интерполяция: `f"x={x}"`)
  - `b"..."` — байтовая строка (`bytes`)
  - Комбинации: `fr"..."`, `rf"..."` и т.д.

**Лексически**:  
Весь литерал — один токен типа `STRING`.  
Префикс (например, `f`, `r`) — часть токена `stringprefix`.  
**Пробел между префиксом и кавычкой запрещён**: `f "x"` → ошибка.

**Escape-последовательности** (например, `\n`, `\t`, `\"`) обрабатываются **только если нет `r`/`R`**.

**Примеры токенов**:
```python
"hello"        → STRING('"hello"')
'hello'        → STRING("'hello'")
"""line1
line2"""       → STRING('"""line1\nline2"""')
f"x={x}"       → STRING('f"x={x}"')
r"C:\path"     → STRING('r"C:\\path"')  # бэкслеши буквальные
```

#### **C++**

**Формы записи**:
- Обычные строки: `"hello"` → тип `const char[6]` или `std::string`.  
- Raw-строки (C++11+): `R"(C:\path)"` → позволяет избежать экранирования  
- UTF-8 строки: `u8"привет"` → тип `const char8_t[]` (C++20)  
- Wide-строки: `L"wide"` → `const wchar_t[]`

**Нет интерполяции**: нельзя вставить переменную внутрь строки.  
Escape-последовательности всегда обрабатываются: `"C:\\path"`  
Raw-строки: `R"delimiter(...content...)delimiter"` — содержимое **не обрабатывается**.

**Примеры**:
```cpp
"hello"           // const char[6]
"C:\\path"        // содержит один обратный слэш
R"(C:\path)"      // то же самое, но без экранирования
u8"Hello, мир!"   // UTF-8 строка (C++11+, char8_t с C++20)
```
---

## 5. Выражения и операторы

В обоих языках выражения строятся из **операндов** (литералов, имён переменных и т.д.) и **операторов**. Однако **лексическое представление операторов** и их **поведение** различаются.


### 5.1. Арифметические операторы

#### Общие операторы
Оба языка поддерживают:
- `+` — сложение  
- `-` — вычитание (или унарный минус)  
- `*` — умножение  
- `/` — деление  
- `%` — остаток от деления

#### **Python**

Арифметические операторы — это **оператор-токены** (`PLUS`, `MINUS`, `STAR`, `SLASH`, `PERCENT`).

Особенности:
- **`/` всегда возвращает `float`**, даже если делятся целые:
  ```python
  7 / 2   # → 3.5 (тип float)
  ```
- **`//` — отдельный оператор** (floor division), возвращает целое или `float`, если один из операндов `float`:
  ```python
  7 // 2   # → 3 (int)
  7.0 // 2 # → 3.0 (float)
  ```

Лексически `//` — **один токен** (`DOUBLESLASH`), а не два `/`.

#### **C++**

Арифметические операторы — **токены-символы**: `+`, `-`, `*`, `/`, `%`.

Особенности:
- **Тип результата зависит от типов операндов**:
  ```cpp
  int a = 7, b = 2;
  double x = 7.0;

  a / b   // → 3 (int, целочисленное деление)
  x / b   // → 3.5 (double)
  ```
- **Нет оператора `//`** — для целочисленного деления используется обычный `/` с целыми операндами.

В C++ нет встроенного эквивалента `//`. Чтобы получить «пол деления», нужно использовать `std::floor(a / b)` для вещественных или просто `/` для целых.

---

### 5.2. Логические операторы

#### **Python**

Логические операторы — это **hard keywords**:

- `and` → токен `AND`
- `or` → токен `OR`
- `not` → токен `NOT`

Пример:
```python
if x > 0 and y < 10:
    print("valid")
```

Токены:
- `NAME('x')`, `GT`, `NUMBER('0')`, `AND`, `NAME('y')`, `LT`, `NUMBER('10')`

#### **C++**

Логические операторы — **символьные токены**:

- `&&` — логическое И (токен `LOGICAL_AND`)
- `||` — логическое ИЛИ (токен `LOGICAL_OR`)
- `!` — логическое НЕ (токен `NOT`)

Пример:
```cpp
if (x > 0 && y < 10) {
    std::cout << "valid";
}
```

Токены:
- `IDENTIFIER(x)`, `GT`, `INT(0)`, `LOGICAL_AND`, `IDENTIFIER(y)`, `LT`, `INT(10)`

---

### 5.3. Операторы сравнения

#### Общие операторы
Оба языка поддерживают:
- `==` — равно  
- `!=` — не равно  
- `<`, `>`, `<=`, `>=` — сравнения

Лексически — это **оператор-токены**: `EQ`, `NE`, `LT`, `GT`, `LE`, `GE`.

#### **Python: цепочки сравнений**

Особенность Python — **поддержка цепочек сравнений**:
```python
a < b < c
```

Это **не два отдельных сравнения**, а **единое выражение**, эквивалентное:
```python
(a < b) and (b < c)
```

Но **лексически** это:
- `NAME('a')`, `LT`, `NAME('b')`, `LT`, `NAME('c')`

Анализатор видит **два оператора `<` в одном выражении**, и грамматика Python допускает такую конструкцию.

#### **C++: цепочки запрещены**

В C++ выражение:
```cpp
a < b < c
```
интерпретируется как:
```cpp
(a < b) < c
```
Сначала вычисляется `a < b` → результат `bool` (`0` или `1`), затем сравнивается с `c`.

Пример:
```cpp
int a = 1, b = 2, c = 3;
bool result = a < b < c; // → (1 < 2) → true (1), затем 1 < 3 → true
```

Но если `c = 0`, то:
```cpp
a < b < 0  // → (1 < 2) → 1, затем 1 < 0 → false
```
 
> Правильный способ в C++:
> ```cpp
> (a < b) && (b < c)
> ```

---

## 6. **Пользовательские составные типы данных**

### Массивы / списки

#### **Python**
  - Литерал списка: `[1, 2, 3]` — **list display**, состоит из:  
    - `[` и `]` — **delimiters**  
    - элементы — выражения, разделённые запятыми  
  - Тип `list` — динамический, гетерогенный (элементы могут быть разных типов)

#### **C++**
  - Статический массив: `int arr[5];`  
  - Динамический: `std::vector<int> v{1, 2, 3};`  
  - Все элементы одного типа

### Структуры (записи)

#### **Python** 

  **Нет встроенной лексической конструкции** для объявления структур в чисто императивном стиле.  
  **Ближайшие аналоги**:

  1. **Класс без методов** (императивно допустимо):  
        ```python
        class Point:
            pass
        p = Point()
        p.x = 1
        p.y = 2
        ```
        — Это **лексическая конструкция** (`class`), но требует последующего присваивания атрибутов.

  2. **Словарь (dict display)**:  
        ```python
        point = {'x': 1, 'y': 2}
        ```
        - Литерал: `{` + последовательность `ключ: значение`, разделённых запятыми + `}`.  
        - Ключи обычно строки или неизменяемые объекты.  
        - Не обеспечивает фиксированной структуры (можно добавлять/удалять ключи).


#### **C++**

- **Лексическая конструкция `struct`**:  
  ```cpp
  struct Point {
      int x, y;
  };
  ```
  - Ключевое слово: `struct`.  
  - Идентификатор: `Point`.  
  - Тело: заключено в фигурные скобки `{}`, содержит объявления полей (и, опционально, методов).  
  - По умолчанию все поля **публичные** (в отличие от `class`).

- **Инициализация — aggregate initialization**:  
  ```cpp
  Point p = {1, 2};
  // или (начиная с C++11)
  Point p{1, 2};
  ```
  - **Aggregate** — это тип (в т.ч. `struct`), у которого:
    - нет пользовательских конструкторов,
    - нет приватных/защищённых полей,
    - не виртуальных функций и т.д.
  - Такие типы можно инициализировать **списком значений в фигурных скобках** — это называется **aggregate initialization**.  
  - Порядок значений соответствует порядку объявления полей в структуре.  
  - Не требует явного конструктора.

> Пример:
> ```cpp
> struct Color {
>     double r, g, b;
> };
> Color c{0.5, 0.8, 1.0}; // корректная aggregate initialization
> ```

---


### 7. **Функциональные элементы**

#### **Python**

1. **Функции как объекты первого класса**  
   - Функции можно присваивать переменным, передавать как аргументы, возвращать из других функций:
     ```python
     def square(x): return x * x
     f = square
     print(f(5))  # 25
     ```


2. **Анонимные функции (`lambda`)**  
   - Краткая запись для простых функций:
     ```python
     add = lambda x, y: x + y
     ```

3. **Встроенные функции высшего порядка**  
   - `map(func, iterable)` — применяет `func` к каждому элементу:
     ```python
     list(map(lambda x: x**2, [1, 2, 3]))  # [1, 4, 9]
     ```
   - `filter(pred, iterable)` — оставляет элементы, для которых `pred` истинно:
     ```python
     list(filter(lambda x: x > 0, [-1, 2, -3, 4]))  # [2, 4]
     ```

---
